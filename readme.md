# Gait detecting system
基于Cpp11实现的人体下肢行为识别系统设计，意在为一套可穿戴式的外骨骼设备提供步态检测识别结果的控制指令，实现外骨骼设备助力、辅助行走等实际应用。
我们这个项目是其中的子项目，实现了一套可用于移动终端设备的人体下肢行为识别系统。
通过对sEMG信号和IMU信号的特征融合，对下肢行为进行识别，意在实现对跨用户的数据自动标注与模型训练，减少识别耗时，使行为识别系统作用于新用户时依然有优秀的识别准确率。
## 概括
实现的人体下肢行为识别系统分为两部分：
- 1 下位机数据采集与行为识别系统，主要实现sEMG信号、IMU信号和FOOT Switch信号的数据采集和同步，基于sEMG信号和IMU信号实现人体下肢各步态行为与步态相位的实时识别和通信功能。
- 2 上位机用户终端图形界面，主要实现各种下肢行为的步态相位划分、数据自动标注、数据集制作和模型训练与移植等功能。

## 系统整体框架
- 整个项目采用并发多进程系统整体实现。
- 整个项目的实现分为上位机Gra3_0用户终端图形界面和下位机EMG数据采集与行为识别系统两部分。
- 上位机主要实现界面设计方面的工作，实现和实验人员的交互作用，效果展示等作用。
- 上位机主要完成的工作是对平地行走、上楼梯、下楼梯，上坡、下坡和跳跃等六个步态划分阶段以及每个阶段的五个状态的结果展示，实现了数据的自动标注。
- 上位机主要会展示连接状态、识别时间以及各个步态的划分结果，还包括数据标注、模型移植等方面的按钮。
- 界面主要是在Qt环境下基于C++多线程高并发等功能实现的人机交互系统。
- 下位机实现sEMG、IMU和FOOT三个信号数据的采集和数据的传输工作。
- 下位机实现对传感器的初始化，设置传感器状态等操作。
- 下位机负责对采集数据的处理和活动段的检测以及步态阶段的划分等模块的具体实现。
- 下位机主程序下开辟4个主进程，每个进程下开辟各自的子进程。
- 分别是：
- 主程序
- 数据采集主进程----ADC数据采集子进程 IMU数据采集子进程 足底压力数据子进程（并设置三个信号量实现这三个数据采集进程的同步问题）
- 活动段检测主进程----活动段端点检测子进程
- 活动段数据处理子进程----活动段数据处理子进程
- TCP传输主进程


## 主要实现技术
- Linux下常用操作、cmake文件编写等。
- Qt关于信号和槽的设计。
- 数据检测算法的实现。
- 数据滤波算法的实现。
- 自定义工具函数类、数据采集类、活动段检测类、网络类、多线程类等多个功能类。
- 实现将复杂类的分离，单独用一个进程代替，使整体代码清晰明了，降低代码耦合。
- 实现BP神将网络模型的前向传播算法移植。
- 实现基于BP神经网络特征向量的模式识别来进行活动段划分。
- 实现单独设计神经网络类进程特征识别。
- 局域网下实现客户端和服务端连接通信。
- 基于SSH工具实现对下位机的远程控制。
- 多线程实现六个步态数据集的循环采集。
- 采用Linux下的定时器机制实现数据的重采样，控制采样速率。
- 采用滑动窗机制和时间窗机制实现采集满数据的控制，进而通知相应的进程处理数据。
- 使用信号、信号量、共享内存等实现线程之通信和同步问题，完成对临界资源的限制性访问和保证临界区的安全。
- 参考生产者-消费者模型实现对共享内存中的数据管理。
- 实现日志系统的设计，监视程序及设备运行状态，记录出现的问题。
- 用vector容器实现了一个可自动扩容的缓冲区。
- 利用单例模式实现了一个简单的线程池，减少了线程创建与销毁的开销。
- AD转换模块的设计 SPI通信相关的技术；
- 多传感器数据特征融合，双分支融合模型；


## 设备环境要求
- Linux-RaspBerry Pi
- C/C++11
- 设备及软件要求：树莓派 AD控制板 计算机 Qt编程软件 Xshell Xftp
- 树莓派、湿电极、惯性测量单元。



## 整体程序框架
### 上位机(upptercomputer)整体代码目录树
```
.
├── bin
│   └── uppercomputer 可执行文件
├── build
│   └── Makefile
├── code             源代码
│   ├── ActiveSection      活动段检测部分
│   ├── config       配置文件
│   ├── Dataset     数据集制作部分
│   ├── filterdata       数据滤波部分
│   ├── FootDetect        根据足底开关信号检测足部事件处理代码
│   ├── main.cpp     主函数
│   ├── IMUPitchDetect      IMU姿态传感器数据特殊点检测模块
│   ├── JumpFootDetect  跳跃动作滞空检测阶段
│   ├── mainwindow   主界面
│   ├── MyDataStruct  制作自己的数据集阶段
│   ├── mypushbutton  Qt里的按钮和槽
│   ├── MyThread  自定义线程，完成数据标注，制作数据集工作。
│   ├── Mytool  工具函数
│   └── tcpclient       自定义tcp连接类：上位机充当和下位机建立连接的上位机
├── log              日志目录
├── Makefile
├── README.md
└── resources        静态资源
```

### 下位机(lowercomputer)整体代码目录树
```
.
├── bin
│   └── lowercomputer 可执行文件
├── build
│   └── Makefile
├── code             源代码
│   ├── CMakeLists cmake文件 
│   ├── BP_DATA、BPNet、class_Dense 手写的BP网络模型结构  
│   ├── ADC_OL sEMG信号采集芯片AD7606初始化
│   ├── CAN_class      can通信类
│   ├── FootDetect        足底压力检测模块
│   ├── config.h     配置文件
│   ├── data_ADC_main sEMG信号采集进程
│   ├── data_Foot_main  足底开关信号采集进程
│   ├── IMU_data   IMU传感器初始化类   
│   ├── data_IMU_main  IMU信号采集进程  
│   ├── main_data 数据同步类  
│   ├── data_WIN  数据窗类
│   ├── dsp_ACT  判断活动段类
│   ├── dsp_RCGClass   调用行为模型类   
│   ├── filt_ADC  数据滤波  
│   ├── global 全局变量 定义结构体  
│   ├── main_dsp  处理数据 判断活动段
│   ├── dsp_RCG_main  处理数据，进行行为识别
│   ├── main_tcp 建立TCP\IP连接通信 下位机为服务端 上位机为客户端
│   └── main       程序入口
├── log              日志目录
├── Makefile
├── README.md
└── resources        静态资源
```



## 遇到的问题

- 1 关于进程退出后资源的回收问题：用线程池来解决；
- 2 关于旧的代码过于冗余复杂的问题：将复杂类的实现单独分离用一个进程或线程来实现。
- 3 关于活动段处理子进程中的大量数据拷贝造成的资源消耗过大问题：移动内存move；
- 4【重点】 关于如何实现对临界区的保护和对临界资源的限制访问：信号量（设计几个信号量也是会遇到的一个问题）
- 5 关于信号量的数量和共享内存的数量是否应该一致的问题。
- 6 关于共享内存映射到当前进程的地址空间的问题。
- 7 【重点】关于异常信号的如何处理的问题：用守护进程来处理异常信号，等待子进程的结束。
- 8 关于数据采集的同步问题和何时进行数据共享的设计：三种数据的采样周期不一致，分别是1ms,5ms,10ms.同时使用滑动窗机制进程数据的缓存设计。
- 9 【重点】上述方案是为了解决数据异常和数据不一致问题而出现的。
- 10 关于锁的选择使用问题：用自旋锁代替mutex实现消耗时间的减少。
- 11 【重点】数据大量注入导致进程崩溃的问题（数据格式不正确、数据错乱问题）。解决方案就是8
- 12 【重点】缓存中的数据无法正常激活函数进行特征提取和模式识别的问题。数据量不够，数据不符合标准等。解决方案参考8
- 13 数据更新问题，如何保证参与特征向量计算的数据是最新的。
- 14 【重点】对于进程何时退出的思路设计：设置一个死循环，每隔1ms就判断是否接收到SIGINT信号，收到信号后会将进程状态设置为退出------软中断；
- 15 使用wait或waitpid函数实现子进程的退出；
- 16 设计三个信号实现进程退出（通过ctrl+c这个软中断实现进程退出）：
- SIGINT信号：当进程捕捉到这个信号后，向主进程发送这个信号，通知主进程退出
- SIGUSER1信号：当捕捉到这个信号后，标志着主进程要求本进程退出，那么该进程的状态设置为退出状态
- SIGALRM信号:这是在数据采集过程中为了捕捉时钟中断，从而控制采集进程的信号
- 17 关于数据采集进程的控制：初始化一个定时器，这个定时器每隔1ms执行一次，将信号发送给数据采集进程，来控制采集进程；然后程序陷入死循环，进行数据采集；
- 18 【重点】关于如何保证共享内存中是最新采集到的数据的方案：
- 设置两个进程dis_ADC(Tnow) dis_IMU（Tnow)实现将最新采集到的数据保存在共享内存中；
- ADC每隔1ms采样一次，IMU每隔10ms采样一次，每次读取IMU和ADC共享内存中的数据后，将它的标志设置为false,表示不是最新的数据；
- 然后将数据保存在离线文件中;
- 将滤波之后的数据保存在滑动窗口内，以便用于特征提取;
- 滑动窗机制：如果当前保存的数据长度大于滑动窗口的长度，就会将数据从滑动窗口中提取出来，保存到共享内存中，更新共享内存中的事件，然后清除一级缓存，将共享内存中dsp设置为真，给数据处理进程发送信号;
- 时间窗机制：然后判断时间窗是否满40ms,如果足够，就将数据保存到数据处理的共享内存中，然后清楚本次的数据采集窗口，通知数据处理子进程进行数据处理;
- 19 关于数据的一个流程：
- 采样--共享内存--离线文件（滤波）--滑动窗口--共享内存
- 20 【重点】对于数据采样过程中采样率的保证：
- ADC每次转换前都要判断上一次转换的数据是否已经被读取走了，如果没有的话，就不进行转换，这样可以保证采样率；
- 进行一次ADC采样，获取一帧新的数据，在获取数据之前，需要读取BUSY的电平值，如果为低，则整明转换完成，可以进行数据读取；
- 首先将SPI的片选选中，通过树莓派的库函数读取SPI的信号，将其保存在一个缓存中;
- 然后拉高片选，整明读取完毕，然后将读取到的16字节数据，联合成16位的数据;
- 21 二级缓存的设计实现将数据段保存到活动段检测的窗口中
-  一级缓存主要是将数据保存下来
- 二级缓存主要是讲数据保存在活动段窗口中 进行活动段的检测



## 一些备注
- 新旧版本的区别：dsp_RCG_main.cpp中关于步态划分的区别
